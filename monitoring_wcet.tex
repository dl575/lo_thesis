\chapter{Worst-Case Execution Time Analysis for Parallel Run-Time Monitoring}
\label{chap:monitoring_wcet}

In order to apply run-time monitoring to traditional real-time systems, we must
be able to analyze the worst-case execution time (WCET) of running a program
with run-time monitoring. The only existing way to do this is to assume that
monitoring is done sequentially. However, this bound is conservative but overly so.

\section{Run-Time Monitoring Architecture}

\section{WCET Analysis}

\subsection{Implicit Path Enumeration}
\label{sec:formulation:ipet}

Most of the WCET analysis techniques today rely on an ILP formulation that is 
obtained from implicit path enumeration techniques \cite{li-ipet-dac95}. 
In this method, a program is converted to a control flow
graph (CFG). From the control flow graph, an ILP problem is formulated that
seeks to maximize
\begin{align*}
  t = \sum_{B \in \mathcal{B}_{CFG}}{N_B \cdot c_{B,max}}
\end{align*} 
where $\mathcal{B}_{CFG}$ is the set of basic blocks in the control flow graph. $N_{B}$
is the number of times block $B$ is executed and $c_{B,max}$ is the maximum number of cycles
to execute block $B$. The maximum value of $t$ is the WCET of the task.  To
account for the fact that only certain paths in the graph will be executed, a
set of constraints are placed on $N_{B}$. For example, on a branch, only one of
the branches will be taken on each execution
of the block. A variable can be assigned to each edge corresponding to the
number of times that edge is taken.
The number of times edges out of the block are taken must equal the number of
times the block is executed.
 Similarly,
the number of times edges into the block are taken must equal the number of
times the block is executed. Various methods have been developed to
create additional constraints to convey other program behavior \cite{li-ipet-dac95, wcetsurvey-tecs08}.
%such as loop
%bounds \cite{li-ipet-dac95} or infeasible paths \cite{suhendra-infeasible-dac09}.

%% Why ILP?
Integer linear programming is an attractive optimization technique
for this problem because the solution found is a global optimum. In
addition, many aspects of program and architecture behavior can be described by
adding constraints to the ILP problem. 
% There have also been several open source
% and commercial ILP solvers written which can be used to find the solution once
% the ILP problem has been formulated. 
Several open source and commercial ILP solvers exist which can solve the formulated ILP problem.
Thus, in developing a method for
estimating the WCET of parallel run-time monitoring, we look to build upon this
ILP framework.

%% Using worst case stalls in original WCET analysis to determine WCET with monitoring.
The IPET-based ILP formulation can be 
extended in a straightforward fashion to incorporate run-time monitoring overheads
if we have the maximum (worst-case) 
%number of cycles that each basic block in the main 
%task spends stalled due to run-time monitoring by maximizing
monitoring stall cycles for each basic block by maximizing
\begin{align*}
  t = \sum_{B \in \mathcal{B}_{CFG}}{N_{B} \cdot (c_{B,max} + s_{B,max})}
\end{align*}
Here, $s_{B,max}$ represents the maximum number of cycles that block $B$ is stalled 
due to monitoring. In this sense, the challenge in WCET analysis with
monitoring lies in determining $s_{B,max}$. 
The rest of this section addresses this problem.

\subsection{Sequential Monitoring Bound}
\label{sec:formulation:sequential}

One way to determine a conservative bound on the worst-case monitoring stall cycles 
is to consider sequential monitoring.
%rather than parallel monitoring. 
In
sequential monitoring, the monitoring task is run in-line with the main task on the same core
rather than in parallel. That is, after each instruction that would be
forwarded, the monitoring task is run on the main core before the main task
resumes execution. In this case, the WCET estimate can be obtained from 
a traditional method by analyzing one program that contains both main and
monitoring tasks.
The resulting WCET can be considered as a simple bound
for parallel monitoring because it models the case where every forwarded 
instruction causes the main core to stall.
%while the monitoring task is performed. 
However, this bound is
extremely conservative as it does not account for the FIFO buffering or the
parallel execution of the monitoring core. These features are critical to
utilizing run-time monitoring techniques while maintaining low performance
overheads.

% \section{Parameter-Based Method}
% \label{sec:formulation:param}
% 
% % Parameters
% \begin{table}
%   \begin{center}
%     \begin{small}
%     \input{tabs/params}
%     \end{small}
%     \caption{Parameters for parameter-only estimation of worst-case stalls.}
%     \label{tab:formulation.params}
%     \vspace{-0.2in}
%   \end{center}
% \end{table}
% 
% A rough estimate of the worst-case number of cycles stalled can be obtained
% given some parameters describing the main task and the monitoring task. These
% parameters are summarized in Table~\ref{tab:formulation.params}. Suppose that
% the main program has $n_{mon}$ instructions to be monitored. For each monitored
% instruction, the monitoring program has a WCET of $t_{mon}$ to handle the
% instruction. Let the main program's original WCET be $t_{main}$ and the length
% of the FIFO connecting the main and monitoring cores is $n_F$ entries. Given
% only these set of parameters to describe the system, it is unknown whether the
% occurrence of monitored instructions is bursty or sparse. If the monitored
% instructions are sparse then the FIFO can mitigate the amount of cycles
% stalled. However, if the monitored instructions are bursty, then more pressure
% is placed on the FIFO and stalls may increase. Thus, in the worst-case, with
% only these parameters, it must be assumed that all monitored instructions are
% executed consecutively. In this case, it can only be assumed that $n_F + 1$
% monitored instructions do not cause stalls. That is, once the FIFO fills, all
% monitored instructions will cause the main program to stall. An additional
% instruction beyond the FIFO length can be accommodated by being processed by
% the monitoring core and does not need to remain in the FIFO buffers. The amount
% of cycles stalled is then
% \begin{align*}
%   t_{stall} =& (n_{mon} - (l_F + 1)) \cdot t_{mon}
% \end{align*}
% The WCET of the main program with monitoring is then
% \begin{align*}
%   t_{total} =& t_{main} + t_{stall} \\
%   =& t_{main} + (n_{mon} - (l_F + 1))t_{mon}
% \end{align*}
% 
% This estimate is quite conservative because of the assumption that must be made
% that all monitored instructions occur together. By using the program binary, it
% can be determined when monitored instructions occur. However, the assumption
% really stems from the fact that a simple set of parameters cannot fully
% describe the complex interaction of the FIFO with the main and monitoring task.
% A more detailed model of the FIFO needs to be created. 

\subsection{FIFO Model}
\label{sec:formulation:model}

To obtain tighter WCET bounds, we need to model the FIFO.
The main task can continue its execution as long as a
FIFO entry is available, but needs to stall on a forwarded instruction if
the FIFO is full. The WCET model needs to capture the worst-case (maximum)
number of entries in the FIFO at each forwarded instruction and determine
how many cycles the main task may be stalled due to the FIFO being full. Here,
we propose a mathematical model to express the load in the FIFO and estimate the worst-case stalls.

%In this section, we create a mathematical model to describe the FIFO
%behavior and monitoring stall with respect to the main task. We use similar
%methods as traditional WCET analysis using IPET in order to model the stalls.

In this approach, the original control flow graph must be transformed so that 
each node contains at most one forwarded instruction which is located at the
end of the code sequence represented by the node.
This transformed graph is called a {\em monitoring flow graph (MFG)}.
Intuitively, the analysis needs to consider one forwarded instruction at a time
in order to model the FIFO state on each
forwarded instruction and capture all potential stalls from monitoring. 

To model how full the FIFO is, we define the concept of \emph{monitoring load}.
The monitoring load is the number of cycles required for the monitoring core 
to process all outstanding entries in the FIFO at a given point in time.
The monitoring load increases when a new instruction is 
forwarded by the main task, and decreases as the monitoring core processes
forwarded instructions.  For simplicity, the increase in monitoring load
for any forwarded instruction is conservatively assumed to be the worst-case (maximum) monitoring task
execution time among all possible forwarded instructions. This maximum, $t_{M, max}$, can be obtained from the WCET analysis of the monitoring tasks.
We make this simplification because it is difficult to model the FIFO
mathematically at an entry-by-entry level. With this simplification, each FIFO
entry is identical and so the monitoring load fully represents the state of the FIFO.
% It is difficult to instead model the FIFO mathematically at an
% entry-by-entry level. For example, for two FIFO states with differing entries,
% it is unclear which is the worst-case state without simulating each entry.
The monitoring load cannot be negative and is upper-bounded by the maximum
monitoring load the FIFO can handle, $l_{max}$.  The maximum monitoring load is
the number of FIFO entries, $n_F$, multiplied by the 
% maximum number of cycles
% that the monitoring task can take on one forwarded instruction, $t_{M,max}$,
increase in monitoring load for one forwarded instruction, $t_{M, max}$.
%which can be obtained from the WCET analysis of the monitoring tasks. 

%depending on the number of cycles needed by the
%monitoring task to handle that forwarded instruction. Monitoring load serves as
%a representation of how full the FIFO is. It can also be considered at a given
%point in the main task's code. 

In our context, we need to determine the worst-case (maximum) monitoring load
at the node boundaries in the MFG. 
For a given node, $M$, in the MFG, we define $li_{M}$ as the monitoring load
coming into the node and $lo_{M}$ as the monitoring load exiting the node. The
change in monitoring load for the node is denoted by $\Delta l_{M}$. The maximum
$\Delta l_{M}$ can be calculated as the difference between the WCET of a monitoring
task that corresponds to $M$ and the minimum execution cycles of the node,
$c_{M,min}$: 
\begin{align*}
\Delta l_{M} = 
	\begin{cases}
	t_{M,max} - c_{M,min}, &\text{forwarded inst. } \in M \\
	- c_{M,min}, &\text{no forwarded inst. } \in M
	\end{cases}
\end{align*}
In order to ensure that the analysis is conservative in estimating the worst-case 
(maximum) stalls, we use 
%the worst-case execution time for the monitoring task and 
the best-case (minimum) execution time for the main task here. 
% In particular, we use the worst-case
% processing time for all possible forwarded instructions, $t_{M,max}$, rather than
% a different execution time for each forwarded instruction.
%Here, the worst-case monitoring load for one forwarded instruction 
%l_{max}$, the worst-case cycles to process a forwarded instruction among all
%possible forwarded instructions. 
% This worst-case assumption is needed here
% because we are modeling monitoring load rather than the individual FIFO
% entries.

%The best-case is used here because the
%worst-case cycles of monitoring stalls occur when the time between forwarded
%instructions is minimized. 
%In order to ensure the analysis to be conservative, 
%the monitoring load added for a monitored instruction is assumed to be $\Delta
%l_{max}$, the worst-case cycles to process a forwarded instruction among all
%possible forwarded instructions. This worst-case assumption is needed here
%because we are modeling monitoring load rather than actual FIFO entries. Thus, 

Because the monitoring load is bounded by zero and the maximum load that
the FIFO can handle, $l_{max}$, the monitoring load coming out of a node is
\begin{align*}
	lo_{M} =& 
		\begin{cases}
			0, &li_{M} + \Delta l_{M} < 0 \\
			li_{M} + \Delta l_{M}, &0 \leq li_{M} + \Delta l_{M} \leq l_{max} \\
			l_{max}, &li_{M} + \Delta l_{M} > l_{max}
		\end{cases} \\
  l_{max} =& n_F \cdot t_{M,max}
\end{align*}

The worst-case monitoring load entering node $M$, $li_{M}$, is the largest of the
output monitoring loads among nodes with edges pointing to node $M$. Let
$\mathcal{M_{\text{prev}}}$ represent the set of nodes with edges pointing to node $M$.
Then,
\begin{align*}
	li_{M} = \max_{M_{prev} \in \mathcal{M}_{prev}}lo_{M_{prev}}
\end{align*}

The above equations describe the worst-case monitoring load at each node boundary.
A monitoring stall occurs when a forwarded instruction is executed 
but there is no empty entry in the FIFO buffer. In terms of monitoring
load, if a node would add monitoring load that would cause the resulting total load
to exceed $l_{max}$, then a monitoring stall occurs. The number of cycles
stalled, $s_{M}$, is the number of cycles that this total exceeds $l_{max}$.
% The monitoring stall cycles for node $M$, $m_{M}$, can be obtained from the 
% difference between the unbounded monitoring load, $li_{M} + \Delta l_{M}$ and
% the maximum monitoring load, $l_{max}$. 
That is,
\begin{align*}
	s_{M} =
		\begin{cases}
			0, &li_{M} + \Delta l_{M} < l_{max} \\
			(li_{M} + \Delta l_{M}) - l_{max}, &li_{M} + \Delta l_M \geq l_{max}
		\end{cases}
\end{align*}

%These set of equations describe the monitoring stalls for each node in the MFG,
%using monitoring load as an intermediate variable.
Then, the worst-case monitoring stall cycles for each MFG node can be obtained by maximizing
the sum of the $s_{M}$ across all possible execution paths: 
%can be determined by maximizing the value of each $s_B$.
%This is equivalent to a single objective of maximizing the sum of the $s_B$,
\begin{align*}
  \max \sum_{M \in \mathcal{M}_{MFG}} s_{M}
\end{align*}
where $\mathcal{M}_{MFG}$ is the set of nodes in the MFG.
Once the worst-case stalls for each MFG node is found, the worst-case stalls for
a CFG node, $s_{B,max}$, can be computed by simply summing the stalls from the corresponding MFG 
nodes. We note that since the monitoring
load is always conservative in representing the FIFO state, no timing anomalies
are exhibited by this analysis. That is, determining the individual worst-case
stalls results in the global worst-case stalls.

\subsection{MILP Formulation}
\label{sec:formulation:milp}

%This objective is linear and so lends itself to LP.  However, several of the
%equations presented in this section for calculating the monitoring load are
%not linear, due to the non-linear behavior of the FIFO. If these equations can
%be converted into linear constraints, then the worst-case monitoring stalls can
%be determined using an LP solver. The following section shows how to convert
%these equations into sets of linear constraints to create a mixed integer
%linear programming problem.

The proposed FIFO model requires solving an optimization problem to obtain the
worst-case stalls, where the input and output monitoring loads, $li_{M}$ and $lo_{M}$, 
and the monitoring stalls, $s_{M}$, need to be determined for each node. Here, we show how
the problem can be formulated using MILP. Although the equations 
for $lo_{M}$ and $s_{M}$ are non-linear, they are piecewise linear. Previous work has
shown that linear constraints for piecewise linear functions can be
formulated using MILP \cite{sierksma-lp}. In the
following constraints, all variables are assumed to be lower bounded by zero
unless otherwise specified, as is typically assumed for MILP.

First, a
set of variables, $lo'$ and $s'$, are created to represent the unbounded
versions of $lo$ and $s$. For readability, the per block subscript $M$ has been
omitted.
% \begin{align*}
% s' =& li + \Delta l - l_{max} \\
% s' >& -\infty \\
% lo' =& li + \Delta l \\
% lo' >& -\infty
% \end{align*}
\begin{align*}
s' =& li + \Delta l - l_{max}, \text{ } s' \in (-\infty, \infty)\\
lo' =& li + \Delta l, \text{ } lo' \in (-\infty, \infty) 
\end{align*}
%Determining $s$ from $s'$ is equivalent to the following piecewise linear
%function.
The following piecewise linear function calculates $s$ from $s'$.
\begin{align*}
s = f(s') = 
  \begin{cases} 
  0, &s' < 0\\
  s', &s' \geq 0
  \end{cases}
\end{align*}
This function can be described in MILP using the following set of constraints.
\begin{align*}
  a_s\lambda_0 + b_s\lambda_2 =& s'\\
  \lambda_0 + \lambda_1 + \lambda_2 =& 1 \\
  \delta_1 + \lambda_2 \leq& 1 \\
  \delta_2 + \lambda_0 \leq& 1 \\
  \delta_1 + \delta_2 =& 1 \\
  b_s\lambda_2 =& s
\end{align*}
where $a_s$ is chosen to be less than the minimum possible value of $s'$ and $b_s$
is chosen to be greater than the maximum possible value of $s'$. The choice of
$a_s$ and $b_s$ is arbitrary as long as it meets these requirements. $\lambda_i$
are continuous variables and $\delta_i$ are binary variables. In this set of
constraints, $s'$ is expressed as a sum of the endpoints of a segment of the 
piecewise function. The $\delta_i$ variables ensure that only the segment
corresponding to $s'$ is considered. $\delta_1 = 1$ corresponds to the $s' < 0$
segment of $f(s')$ and $\delta_2 = 1$ corresponds to the $s' \geq 0$ segment of
$f(s')$. The $\lambda_i$ variables represent exactly where
$s'$ falls on the domain of that segment. $s$ can be calculated using this
information and the values of the function at the segment endpoints.

Similarly, $lo$ can be bound between $0$ and $l_{max}$ by using the following
set of constraints.
\begin{align*}
a_l\lambda_3 + l_{max}\lambda_5 + b_l\lambda_6 =& lo'\\
\lambda_3 + \lambda_4 + \lambda_5 + \lambda_6 =& 1 \\
2 \delta_3 + \lambda_5 + \lambda_6 \leq& 2 \\
2 \delta_4 + \lambda_3 + \lambda_6 \leq& 2 \\
2 \delta_5 + \lambda_3 + \lambda_4 \leq& 2 \\
\delta_3 + \delta_4 + \delta_5 = 1 \\
l_{max}\lambda_5 + l_{max}\lambda_6 =& lo
\end{align*}
As before, $a_l$ and $b_l$ are chosen such that $lo' \in (a_l, b_l)$.
Again, $\lambda_i$ are continuous variables and $\delta_i$  are binary
variables.

Finally, for each node, the input monitoring load $li_{M}$ must be determined.
$li_{M}$ depends on the previous nodes, $\mathcal{M_\text{prev}}$. If there is only
one edge into the node, then $li_M$ is simply
\begin{align*}
li_{M} = lo_{M_{prev}}
\end{align*}
When there is more than one edge into node $M$, one set of constraints is used
to lower bound $li_{M}$ by all $lo_{M_{prev}}$.
\begin{align*}
  li_{M} \geq& lo_{M_{prev}}, \text{ } \forall M_{prev} \in \mathcal{M_\text{prev}}
\end{align*}
Then, another set of constraints upper bounds $li_{M}$ by the maximum $lo_{M_{prev}}$,
\begin{align*}
  li_{M} - b \cdot \delta_{M_{prev}} \leq& lo_{M_{prev}}, \text{ } \forall M_{prev} \in \mathcal{M_\text{prev}} \\
  \sum_{M_{prev} \in \mathcal{M_\text{prev}}}\delta_{M_{prev}} =& |\mathcal{M_\text{prev}}| - 1
\end{align*}
where $b$ is chosen to be greater than $[\max(lo_{M_{prev}}) -\\ \min(lo_{M_{prev}})]$ and
$|\mathcal{M_\text{prev}}|$ is the number of nodes with edges pointing to $M$. $\delta_i$ are binary
variables. The use of the binary variables $\delta_i$ and the second
constraint ensure that $li_{M}$ is only upper bound by one of the $lo_{M_{prev}}$. In
order for all constraints to hold, this must be the maximum $lo_{M_{prev}}$. Together
with the lower bound constraints, these constraints result in $li_{M} =
\max(lo_{M_{prev}})$. For an example of this complete analysis with numbers, see Appendix~\ref{sec:example}.

%%%%%%%%%%%%%%%%%%%%%%%
% Detailed example
%%%%%%%%%%%%%%%%%%%%%%%
%\section{Example of MILP-based method}
\section{Example MILP Formulation}
\label{sec:example}


In this section we show a detailed example of applying our MILP-based method
for estimating the WCET of a task running on a system with parallel run-time
monitoring.

\subsection{Example Setup}

% CFG
\begin{figure}[htb]
  \begin{center}
    \vspace{-0.0in}
    \includegraphics[width=2.0in]{figs/monitoring_wcet/cfg.pdf}
    \vspace{-0.1in}
    \caption{Control flow graph of a main task.}
    \label{fig:app.cfg}
    \vspace{-0.2in}
  \end{center}
\end{figure}

The control flow graph for an example main task is shown in Figure~\ref{fig:app.cfg}. We assume
that the execution time for each node has already been calculated using
previous methods. These execution times are labeled as {\tt cB\_max} in the figure.

In this example, let us assume that the monitoring technique requires loads and stores 
to be forwarded, as
in the case of UMC. The monitoring task requires 5 cycles to handle a load and
7 cycles to handle a store. Thus, the maximum execution time of the monitoring
task, $t_{M, max}$, is 7 cycles.

Because of the simplicity of the example, we assume that the FIFO only holds one entry ($n_F = 1$). Thus, $l_{max} = n_F \cdot t_{M, max} = 7$.

\subsection{Creating the MFG}

The first step is to create the monitoring flow graph. For each node in the
CFG, the code represented by that node is analyzed. After any forwarded
instruction, in this case any load or store instructions, an edge is created,
dividing a node into 2 new ones.
For example, the assembly-level code for node 1 in the CFG is shown below.
\vspace{-0.2in}
\lstset{numbers=left, 
  firstnumber=1, 
  xleftmargin=2em, 
  numbersep=1em, 
  basicstyle=\ttfamily, 
  title=node 1, 
  } 
\begin{lstlisting}[frame=tb]
  add $t0, $t1, $t2
  add $t3, $t4, $t5
  lw  $t4, 0($t3)
  add $t0, $t0, $t4
\end{lstlisting}
Since the third instruction is a load instruction, node 1 must be split into
two nodes in the MFG. The first node represents the first three instructions and
the second node represents the last instruction. 

% MFG
\begin{figure}[htb]
  \begin{center}
    \vspace{-0.0in}
    \includegraphics[width=2in]{figs/monitoring_wcet/mfg.pdf}
    \vspace{-0.1in}
    \caption{Monitoring flow graph of the main task. Blue (dark) nodes indicate ones with a forwarded instruction at the end. Yellow (light) nodes indicate ones without a forwarded instruction.}
    \label{fig:app.mfg}
    \vspace{-0.2in}
  \end{center}
\end{figure}

The full MFG is shown in
Figure~\ref{fig:app.mfg}. Nodes that are blue (dark) include a forwarded
instruction, which is located at the end of the node. Nodes that are yellow
(light) do not include a forwarded instruction. The nodes in the graph are
labeled with minimum ({\tt cB\_min}) rather than maximum execution times. It can be seen that
node 1 from the CFG corresponds to nodes 1.0 and 1.1 in the MFG. In this example,
nodes in the CFG were only transformed into at most 2 nodes in the MFG.
However, in general, a CFG node will be transformed into a number of nodes in
the MFG equal to the number of forwarded instructions plus one.

\subsection{Calculating the Monitoring Load}
Once the MFG is constructed, a set of MILP constraints is generated for each
node. This process can be automated, but for this example we will construct the
constraints for one node by hand. Specifically we will consider node 3.0 in the
MFG. We will also calculate, by hand, the MILP solution for the node using some
assumed values for variables associated with other nodes. Note that all
variables are assumed to be non-negative unless otherwise specified.

{\bf Calculating input monitoring load:}
First, we will determine the worst-case input monitoring load for node
3.0, $li_{3.0}$.  One set of constraints lower bounds the monitoring load by all possible
incoming monitoring loads.
\begin{align*}
  li_{3.0} \geq& lo_{1.1} \\
  li_{3.0} \geq& lo_{2.0} 
\end{align*}
Then, a set of constraints upper bounds this input monitoring load.
\begin{align*}
  li_{3.0} - 1000 \delta_{1.1} \leq& lo_{1.1} \\
  li_{3.0} - 1000 \delta_{2.0} \leq& lo_{2.0} \\
  \delta_{1.1} + \delta_{2.0} =& 1
\end{align*}
Here, the value 1000 is chosen arbitrarily but is known to be greater than
$|lo_{2.0} - lo_{1.1}|$.  A different value could have been chosen as long as this
condition was true. 
$\delta_{1.1}$ and $\delta_{2.0}$ are binary variables which can only assume values of $0$ or $1$.
To see how these constraints work, suppose that $li_{2.0} =
7$ and $li_{1.1} = 4$. The constraints are then evaluated as
\begin{align*}
  li_{3.0} \geq& 4 \\
  li_{3.0} \geq& 7 \\
  li_{3.0} - 1000 \delta_{1.1} \leq& 4 \\
  li_{3.0} - 1000 \delta_{2.0} \leq& 7 \\
  \delta_{1.1} + \delta_{2.0} =& 1
\end{align*}
The first pair of constraints ensures that $li_{3.0} \geq 7$. This means that
for the third constraint to hold, $\delta_{1.1} = 1$. If $\delta_{1.1} = 1$,
then by the last constraint, $\delta_{2.0} = 0$. Plugging this value into the
fourth constraint gives $li_{3.0} \leq 7$. Thus the only possible solution is
$li_{3.0} = 7$.

{\bf Calculating output monitoring load:}
In order to determine the output monitoring load for node 3.0, we must first
calculate the change in monitoring node, $\Delta l_{3.0}$. Since there is a forwarded instruction in node 3.0,
\begin{align*}
  \Delta l_{3.0} =& t_{M, max} - c_{3.0, min} \\
  =& 7 - 4 = 3
\end{align*}
We first create a variable, $lo'_{3.0}$ to represent the unbounded output monitoring load.
\begin{align*}
  lo'_{3.0} =& li_{3.0} + \Delta l_{3.0}, \text{ } lo'_{3.0} \in (-\infty, \infty)
\end{align*}
Using the example input monitoring load previously calculated of $li_{3.0} =
7$, this unbounded output monitoring load is $lo'_{3.0} = 7 + 3 = 10$.
Then, the following set of constraints determines the bounded output monitoring load, $lo_{3.0}$.
\begin{subequations}
\begin{align}
  -1000\lambda_3 + 7\lambda_5 + 1000\lambda_6 =& 10 \label{app:lo1}\\ 
  \lambda_3 + \lambda_4 + \lambda_5 + \lambda_6 =& 1 \label{app:lo2}\\
  2 \delta_3 + \lambda_5 + \lambda_6 \leq& 2 \label{app:lo3}\\
  2 \delta_4 + \lambda_3 + \lambda_6 \leq& 2 \label{app:lo4}\\
  2 \delta_5 + \lambda_3 + \lambda_4 \leq& 2 \label{app:lo5}\\
  \delta_3 + \delta_4 + \delta_5 = 1 \label{app:lo6}\\
  7\lambda_5 + 7\lambda_6 =& lo_{3.0} \label{app:lo7}
\end{align}
\end{subequations}
The -1000 and 1000 values were chosen arbitrarily and only require that
$lo'_{3.0}$ to fall between them. $\delta_3$, $\delta_4$, and $\delta_5$ are binary variables. By Constraint~\ref{app:lo2}, it can be seen that
all $\lambda_i$ are less than or equal to 1. Thus, in order for 
Constraint~\ref{app:lo1} to hold, $\lambda_6 >  0$. Since $\lambda_6 > 0$, Constraints~\ref{app:lo3} and
\ref{app:lo4} force $\delta_3$ and $\delta_4$ to both be zero. From this, by Constraint~\ref{app:lo6},
$\delta_5 = 1$. Then, by Constraint~\ref{app:lo5}, $\lambda_3$ and $\lambda_4$ are both
forced to be zero. If we now go back to the first two constraints, they are
reduced to
\begin{align*}
  7\lambda_5 + 1000\lambda_6 =& 10\\
  \lambda_5 + \lambda_6 =& 1 \\
\end{align*}
Solving this system of equations gives the solution $(\lambda_5, \lambda_6) = (0.997, 0.003)$. Plugging these values into Constraint~\ref{app:lo7},
\begin{align*}
  lo_{3.0} =& 7\lambda_5 + 7\lambda_6 \\
  =& 7\cdot 0.997 + 7\cdot 0.003 \\
  =& 7
\end{align*}
Thus, the output monitoring load is indeed bound by the maximum monitoring load
of 7. Although this may seem to be a complicated series of calculations to
determine this obvious result, this set of constraints is required in order for
the piecewise linear, and thus non-linear, bounding function to be expressed
in an MILP problem.

{\bf Calculating the monitoring stall cycles:} The one remaining value that
needs to be determined for node 3.0 is the monitoring stall cycles. Based on
our previous calculations, the worst-case input monitoring load ($li_{3.0}$) is 7, the
change in monitoring load ($\Delta l_{3.0}$) is 3, and the maximum monitoring load ($l_{max}$) is 7. Thus, we
expect the worst-case monitoring stall cycles to be $(7+3)-7 = 3$. To handle this as an
MILP problem, first the unbounded monitoring stall cycles, $s'$, is calculated.
\begin{align*}
  s'_{3.0} =& li_{3.0} + \Delta l_{3.0} - l_{max}, \text{ } s'_{3.0} \in (-\infty, \infty) \\
  =& 7 + 3 - 7 = 3
\end{align*}
In this case, since $s'_{3.0}$ is positive, we expect $s_{3.0} = s'_{3.0}$. The MILP problem
determines $s_{3.0}$ using the following set of constraints.
\begin{subequations}
\begin{align}
  -1000\lambda_0 + 1000\lambda_2 =& 3 \label{app:s1}\\
  \lambda_0 + \lambda_1 + \lambda_2 =& 1 \label{app:s2}\\
  \delta_1 + \lambda_2 \leq& 1 \label{app:s3}\\
  \delta_2 + \lambda_0 \leq& 1 \label{app:s4}\\
  \delta_1 + \delta_2 =& 1 \label{app:s5}\\
  1000\lambda_2 =& s_{3.0} \label{app:s6}
\end{align}
\end{subequations}
The -1000 and 1000 values are chosen arbitrarily, only requiring that
$s'_{3.0}$ is between them. From Constraint~\ref{app:s1}, $\lambda_2$ must be
positive. Since $\delta_i$ are binary variables, Constraint~\ref{app:s3} then implies that
$\delta_1 = 0$. Constraints~\ref{app:s4} and \ref{app:s5} then force $\delta_2 = 1$ and $\lambda_0 =
0$. The first two constraints then reduce to
\begin{align*}
  1000\lambda_2 =& 3\\
  \lambda_1 + \lambda_2 =& 1 
\end{align*}
Solving this system of equations leads to $(\lambda_1, \lambda_2) = (0.997, 0.003)$ and thus calculating $s_{3.0}$ using Constraint~\ref{app:s6}:
\begin{align*}
  s_{3.0} =& 1000 \lambda_2 \\
  =& 1000 \cdot 0.003 = 3
\end{align*}
This is the value for $s$ that we expected. If $s'$ had instead been negative,
then $\delta_1$ would be forced to 1 and $\lambda_2$ would be forced to 0. From
the last constraint, it can be seen that if $\lambda_2$ is 0, then $s$ is also
0.

\subsection{MILP Optimization}

In the previous subsection, the monitoring loads for one node were calculated
in detail. However, note that the output monitoring load for each node with an
edge pointing to node 3.0 was assumed to be a certain value. In an actual MILP
problem, these would be variables that are also being solved for. Solving for
these inter-related variables and determining the global maximum number of
cycles stalled due to monitoring is impractical to do by hand. 
%for all but the simplest examples. 
While the amount of calculations
may seem excessive for these simple examples, the ability to formulate the
problem in MILP is essential in order to solve large problems.



\vspace{-0.1in}
\section{Evaluation}
\label{sec:evaluation}

% Toolflow
\begin{figure}%[htb]
  \begin{center}
    \vspace{-0.1in}
    \includegraphics[height=2.2in]{figs/monitoring_wcet/toolflow.pdf}
    \vspace{-0.1in}
    \caption{Toolflow for WCET estimation of parallel monitoring.}
    \label{fig:evaluation.toolflow}
    \vspace{-0.3in}
  \end{center}
\end{figure}

% Results
\begin{table*}[htb]
  \begin{center}
    \begin{scriptsize}
    \input{tabs/monitoring_wcet/wcet}
    \end{scriptsize}
    \vspace{-0.1in}
    \caption{Estimated and observed WCET (clock cycles) with and without monitoring.}
    \label{tab:evaluation.wcet}
    \vspace{-0.2in}
  \end{center}
\end{table*}

% Calculated ratios
\begin{table*}[htb]
  \begin{center}
    \begin{tiny}
    \input{tabs/monitoring_wcet/ratios}
    \end{tiny}
    \vspace{-0.1in}
    \caption{Ratios comparing results from different experiments.} \label{tab:evaluation.ratios}
    \vspace{-0.3in}
  \end{center}
\end{table*}

\vspace{-0.0in}
\subsection{Experimental Setup}

Our toolflow for the proposed WCET method is shown in Figure~\ref{fig:evaluation.toolflow}. We
first use Chronos \cite{chronos-tool}, an open source WCET tool, to estimate
the WCET for the main task and the monitoring tasks. We also modified Chronos
to produce a MFG of the main task. This MFG and the monitoring task WCET are used to produce an MILP formulation as in
Section \ref{sec:formulation}. This MILP problem is solved
using lp\_solve \cite{lpsolve}, which produces the worst-case monitoring stall cycles for each forwarded
instruction. These monitoring stalls are combined into the ILP formulation that 
is originally generated for the main task to estimate the overall
WCET with parallel run-time monitoring. Although we use Chronos and lp\_solve
for our implementation, these components can be replaced with any WCET
estimation tool and LP solver respectively.

To evaluate the effectiveness of our WCET scheme, we compared its estimate
with a simple WCET bound from sequential monitoring (Section~\ref{sec:formulation:sequential})
as well as simulation results using the SimpleScalar tool \cite{simplescalar}.
In addition to the WCET estimates with monitoring, we also compared the results with
the WCET of the main task without monitoring, using both Chronos and simulations. 
% The baseline WCET allows us to study the overheads of parallel run-time monitoring
% in terms of the worst-case execution time.

%In order to examine
%how conservative the estimate was, we used the SimpleScalar simulator to
%simulate the benchmarks, both with and without monitoring. 

For the experiments, we configured Chronos and SimpleScalar to model simple processing cores
that execute one instruction per cycle for both main and monitoring cores and used an 8-entry FIFO.
This configuration represents typical embedded microcontrollers, and is designed to focus on 
the impact of parallel run-time monitoring by removing complex features such as branch prediction 
and caches.
%The experiments model an 8-entry FIFO that can buffer up to eight
%forwarded instructions. 
In the evaluation, we used seven benchmarks from the M\"alarden WCET benchmark suite \cite{malarden} 
and two monitoring techniques: uninitialized memory checks (UMC) and control flow protection (CFP).
UMC detects a software bug that reads memory without a write as briefly explained in 
Section~\ref{sec:arch}. CFP protects a program's control flow by checking a target address on
each control transfer \cite{arora-runtime05}. In this technique, a compiler determines a set of valid
targets for each branch and jump in the main task.
This information is stored on the monitoring core. 
On a branch or jump, the monitoring core ensures that the target is
contained in the list of valid targets.


\vspace{-0.05in}
\subsection{Results}

Table~\ref{tab:evaluation.wcet} shows the experimental results for each
benchmark under different configurations. The first set of rows show the WCET 
estimate from Chronos ({\tt wcet-none}) and actual run-times from simulations ({\tt sim-none}) without 
monitoring. The remaining rows show the WCET for the UMC and
CFP monitoring extensions. The results are shown for three different approaches:
a bound from sequential monitoring ({\tt sequential}), our approach ({\tt wcet}),
and simulations ({\tt sim}). The numbers indicate the number of clock cycles.
Appendix~\ref{sec:lptime} includes running times for these experiments.

Table~\ref{tab:evaluation.ratios} shows relative comparisons between
different configurations or WCET methods.
The first set of rows compare the WCET estimates from ILP or MILP formulations
with the worst-case simulation cycles for each monitoring setup. 
The results show that the analytical WCET estimates from our proposed scheme
are larger than the observed WCET by 0\% to 52\% for UMC and 0\% to 71\% for CFP, 
depending on the main task. This difference is comparable to the case without
parallel run-time monitoring, where the analytical WCET from Chronos
is larger than simulation results by 0\% to 52\%. 
In fact, for {\tt expint}, the majority of the difference is from the WCET
estimate of the main task rather than the effects of monitoring.
%In fact, for certain benchmarks, such as {\tt expint}, the majority of the difference 
%is due to estimating the
%WCET of the main task rather than the effects of monitoring. 
This result suggests that our WCET approach is not significantly more conservative than
the baseline WCET tool for the main task.

The second set of rows compare the bound from sequential monitoring and the WCET 
from our proposed method. 
For UMC, our approach shows up to a 74\% reduction in WCET estimates over the simple
bound. Similarly, for CFP, our method shows up to a 73\% improvement.
These results demonstrate that modeling the FIFO decoupling between the main and monitoring
tasks is important for obtaining tight WCET estimates of parallel
monitoring. 

Finally, the last two rows in Table~\ref{tab:evaluation.ratios} compare the WCET 
estimates with and without run-time monitoring.
The results show that the increase in WCET varies significantly depending on
benchmark and monitoring technique. Benchmarks with infrequent monitoring
events (forwarded instructions) show minimal overheads while ones with frequent
monitoring can see significant impacts.
Also, the benchmarks with large WCET increases differ between UMC and CFP.
Therefore, when applying parallel run-time monitoring techniques to real-time systems,
a careful WCET analysis for the given tasks and monitoring techniques 
needs to be performed. 

The impact of run-time monitoring on the execution time in our experiments
(up to 3.48x in UMC and 2.58x in CFP) is roughly in line with previous studies
on multi-cores without any hardware support \cite{chen08-lba, nagarajan08-dift}. 
The performance overheads will be much lower for multi-cores with optimizations 
\cite{chen08-lba} or heterogeneous monitors \cite{flexcore-micro10}. 
Our analysis technique does not depend on any specific monitoring core
microarchitecture and is applicable to more optimized architectures.

%Table~\ref{tab:evaluation.ratios} also compares the WCET estimated with each
%monitoring extension versus the WCET estimated without monitoring. For UMC, the
%WCET is increased by up to 3.48x and for CFP the WCET is increased up to 2.58x.
%However, for both extensions, there also exist benchmarks where the WCET is not
%increased. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% lp_solve time
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Time to Solve Linear Programming Problem}
\label{sec:lptime}

% lp_solve time
\begin{table*}[htb]
  \begin{center}
    \begin{small}
    \input{tabs/monitoring_wcet/runtime}
    \end{small}
    \vspace{-0.1in}
    \caption{Running time of lp\_solve in seconds to determine worst-case stalls
    (stall), sequential bound (sequential), and worst-case execution times (wcet).}
    \label{tab:appendix.runtime}
    \vspace{-0.2in}
  \end{center}
\end{table*}

The most time intensive portion of the WCET analysis is the actual solving of
the linear programming (LP) problem. For our experiments, we used lp\_solve
5.5.2.0 \cite{lpsolve} as our LP solver. These experiments were run on a 2.67
GHz Xeon E5430 quad-core processor with 4 GB of RAM. The running times for
lp\_solve are shown in Table~\ref{tab:appendix.runtime}.  The first set of rows
show the running time for determining the worst-case stalls from the monitoring flow
graph ({\tt stall}). The second set of rows show the lp\_solve running time for
finding the sequential bounds. The final set of rows show the running time for
determining the overall WCET ({\tt wcet}). For {\tt wcet-umc} and {\tt
wcet-cfp}, this is for the ILP problem given the worst-case stalls .

The running times for the {\tt sequential} cases and the {\tt wcet} cases are very
similar. This is because these cases are all solving essentially the same
problem with different numbers. That is, for a given benchmark, these different
cases are all solving a linear programming problem for the same control flow
graph (CFG). As a result, the number of variables and the set of
constraints is the same, though the WCET for each basic block changes depending
on the extension and the estimation method. The {\tt stall} cases have a longer
running time.
This is due to the fact that a MFG has more nodes than its corresponding CFG.
The increased number of nodes also implies more variables and more constraints.


